Development
===========

If you find the openpyxl project intriguing and want to contribute a new awesome
feature, fix a nasty bug or improve the documentation this section will guide you
in setting up your development environment.

We will look into the coding standards and version control system workflows used,
as well as cloning the openpyxl code to your local machine, setting up a virtual
Python environment, running tests and building the documentation.


Getting the source
------------------

The source code of openpyxl is hosted on `Heptapod <https://foss.heptapod.net/openpyxl/openpyxl>`_
as a Mercurial project which you can download using e.g. the GUI client
`TortoiseHg <https://www.mercurial-scm.org/downloads>`_ . If you prefer working
with the command line you can use the following:

.. parsed-literal::

    $ hg clone https://foss.heptapod.net/openpyxl/openpyxl
    $ hg up |version|

Please note that the default branch should never be used for development
work. For bug fixes and minor patches you should base your work on the branch
of the current release, e.g |version|. New features should generally be based
on the development branch of the **next** minor version. If in doubt get in
touch with the openpyxl development team.


Required extensions
-------------------

You will need at least the evolve extension for Mercurial. Check for this using
the command `hg topic` and download it if necessary for your system. You will also need
the eol extension, which is part of Mercurial. Extensions are enabled in
:code:`.hg/hgrc`::

    [extensions]
    evolve =
    eol =

You can then grab any new changes using::

    $ hg pull openpyxl-master

After that you should create a virtual environment using :code:`virtualenv`
and install the project requirements and the project itself::

    $ cd openpyxl
    $ virtualenv openpyxl-env

Activate the environment using::

    $ source bin/activate  # or ./openpyxl-env/Scripts/activate on Windows

Install the dev and prod dependencies and the package itself using::

    (openpyxl-env) $ pip install -U -r requirements.txt
    (openpyxl-env) $ pip install -e .


File Support and Specifications
-------------------------------

The primary aim of openpyxl is to support reading and writing Microsoft Excel
2010 files. These are zipped OOXML files that are specified by `ECMA 376
<http://www.ecma-international.org/publications/standards/Ecma-376.htm>`_ and
`ISO 29500 <http://standards.iso.org/ittf/PubliclyAvailableStandards/index.html>`_.

Where possible we try to support files generated by other libraries or
programs, but can't guarantee it, because often these do not strictly adhere
to the above format.


Branch naming convention
------------------------

We use a "major.minor.patch" numbering system, ie. |release|. Development
branches are named after "major.minor" releases. In general, API change will
only happen major releases but there will be exceptions. Always communicate
API changes to the mailing list before making them. If you are changing an
API try and an implement a fallback (with deprecation warning) for the old
behaviour.

.. note::

    The "default branch" is used for releases and always has changes from a
    development branch merged in. It should never be the target for a pull
    request.


Coding style
------------

We orient ourselves at PEP-8 for the coding style, except when implementing
the OOXML specification which uses camelCase for attribute and child object names.
Don't be afraid to use whitespace to make code easier to read: separate parts
of functions using a separate line and use two lines between functions, methods
and classes.


Contributing
------------

Contributions in the form of pull requests are always welcome. Don't forget
to add yourself to the list of authors!


Pull Requests
+++++++++++++

New features should generally be based on the current, unreleased development
branch, and bug fixes should be made to the relevant release branch
development. Eg. if the current release is |release|, changes should be made
based on the |version| branch, and new features to the development, or
|version| + 0.1 branch. Please ask on the mailing list or bug report if
you're not sure.


Support of Python Versions
++++++++++++++++++++++++++

Make sure that you can test different versions of Python. Currently,
Python 3.8 and upwards is supported.


Topics
++++++

Mercurial uses topics to manage branches for pull requests. Switch to relevant
branch for your work and create a suitable topic. This can be using a bug
number or a brief description of the topic. :code:`hg topic add-text-formatting`.
You switch between topics as you would be between branches.
:code: `hg up add-text-formatting`

Testing
+++++++

Note that contributions to the project without tests will **not** be accepted, but
the focus is very much on unit tests, ie. tests for the lowest level of code.

We use :code:`pytest` as the test runner with :code:`pytest-cov` for coverage
information and :code:`pytest-flakes` for static code analysis.

To run all the tests you need to run::

    (openpxyl-env) $ pytest -xrf openpyxl # this will stop testing at the first error

Please use :code:`tox` to test code for different submissions **before**
submitting a pull request. This is especially important for picking up problems
across Python versions::

    $ tox openpyxl


Organisation
~~~~~~~~~~~~

Tests should be preferably at package / module level e.g for :code:`openpyxl/cell`, the
tests will be in :code:`openpyxl/cell/tests`. Keeping the tests close to the code
generally makes it easier.

Coverage
~~~~~~~~

The goal is 100 % coverage for unit tests - data types and utility functions.
Coverage information can be obtained using::

    py.test --cov openpyxl/cell openpyxl/cell --cov-report=term-missing openpyxl/cell

This will tell you the coverage for the cell module and a list of lines without test coverage.

Document the changes
++++++++++++++++++++

Remember to update the documentation when adding or changing features. Check
that documentation is syntactically correct.::

    tox -e doc


Checking XML
++++++++++++

Use the :code:`openpyxl.tests.helper.compare_xml` function to compare
generated and expected fragments of XML.


Microsoft Tools
~~~~~~~~~~~~~~~

Along with the SDK, Microsoft also has a `"Productivity Tool"
<https://github.com/dotnet/Open-XML-SDK/releases/tag/v2.5>`_ for working
with Office OpenXML.

This allows you to quickly inspect or compare whole Excel files.
Unfortunately, validation errors contain many false positives. The tool also
contain links to the specification and implementers' notes.


Schema validation
~~~~~~~~~~~~~~~~~

When working on code to generate XML it is possible to validate that the
generated XML conforms to the published specification. Note, this won't
necessarily guarantee that everything is fine but is preferable to reverse
engineering!


Documentation
-------------

Any software is only as good as its documentation. We try and provide
documentation that is usable for Python developers but this can always
been improved upon, especially as you become more familiar with the code.
Please get in touch and submit a pull request if you think something is missing
or poorly explained.


Benchmarking
------------

Benchmarking and profiling are ongoing tasks. Contributions to these are very
welcome as we know there is a lot to do.


Memory Use
++++++++++

There is a tox profile for long-running memory benchmarks using the
`memory_utils` package.::

    tox -e memory


Pympler
+++++++

As openpyxl does not include any internal memory benchmarking tools, the
python *pympler* package was used during the testing of styles to profile the
memory usage in :code:`openpyxl.reader.excel.read_style_table()`::

    # in openpyxl/reader/style.py
    from pympler import muppy, summary

    def read_style_table(xml_source):
      ...
      if cell_xfs is not None:  # ~ line 47
          initialState = summary.summarize(muppy.get_objects())  # Capture the initial state
          for index, cell_xfs_node in enumerate(cell_xfs_nodes):
             ...
             table[index] = new_style
          finalState = summary.summarize(muppy.get_objects())  # Capture the final state
          diff = summary.get_diff(initialState, finalState)  # Compare
          summary.print_(diff)


:code:`pympler.summary.print_()` prints to the console a report of object
memory usage, allowing the comparison of different methods and examination of
memory usage. A useful future development would be to construct a
benchmarking package to measure the performance of different components.
